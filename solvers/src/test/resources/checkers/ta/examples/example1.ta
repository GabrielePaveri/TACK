//
// Specification: Autograph Window
//
// Specification was drawn in Autograph version 3.

//
// Global declaration section
//

clock c;
// === Sender_A ===
clock A_c;
int A_Pf, A_Pn, A_S1, A_S2,
  A_start, A_stop;
// === Sender_B ===
clock B_c;
int B_Pf, B_Pn, B_S1, B_S2,
  B_start, B_stop;
// === Frame_Generator_A ===
chan A_frame, A_reset, A_new_Pn;
int A_msg, A_no, A_eof, A_T4;
// === Frame_Generator_B ===
chan B_frame, B_reset, B_new_Pn;
int B_msg, B_no, B_eof, B_T4;
// === Detector_A ===
chan A_check;
int A_err, A_res;
// === Detector_B ===
chan B_check;
int B_err, B_res;
// === Observer_A ===
chan A_observe;
int A_diff;
// === Observer_B ===
chan B_observe;
int B_diff;
// === Bus ===
chan one, zero;

process Sender_A{
	state end_jam, call_observe, start{A_c <= 0}, other_started{A_c <= 3124}, jam{A_c <= 25000}, transmit{A_c <= 781}, ex_start, hold{A_c <= 28116}, idle{A_c <= 781}, call_check, newPn{A_c <= 40}, until_silence{A_c <= 781}, stop, check_eof, sample{A_c <= 781}, goto_idle, ex_jam{A_c <= 781}, nPf, ex_silence2{A_c <= 781}, ex_silence1{A_c <= 2343};
	commit call_observe, ex_start, call_check, check_eof, goto_idle, nPf;
	init start;
	trans 	call_check -> ex_jam{guard A_stop == 0; sync A_check!; assign A_c := 0; },
			call_check -> ex_jam{guard A_stop == 1; assign A_res := 0,A_c := 0; },
			call_observe -> call_check{sync A_observe!; },
			check_eof -> newPn{guard A_eof == 0; sync zero?; assign A_S1 := 0,A_c := 0; },
			check_eof -> newPn{guard A_eof == 0; sync one?; assign A_S1 := 1,A_c := 0; },
			check_eof -> stop{guard A_eof== 1; assign A_c := 0; },
			ex_jam -> jam{guard A_c == 781,A_res == 1; sync A_reset!; assign A_Pn := 0,A_c := 0; },
			ex_jam -> nPf{guard A_c == 781,A_res == 0; },
			ex_jam -> until_silence{guard A_c == 781,A_res == 2; sync A_reset!; assign A_Pn := 1,A_start := 0,A_c := 0; },
			ex_silence1 -> ex_silence2{guard A_c == 2343; sync one?; assign A_c := 0; },
			ex_silence1 -> goto_idle{guard A_c == 2343; sync zero?; },
			ex_silence2 -> goto_idle{guard A_c == 781; sync zero?; },
			ex_silence2 -> transmit{guard A_c == 781; sync one?; assign A_c := 0; },
			ex_start -> ex_silence1{guard B_start == 0; assign A_c := 0; },
			ex_start -> other_started{guard B_start == 1; assign A_c := 0; },
			goto_idle -> idle{assign A_c := 0; },
			hold -> end_jam{guard A_c == 28116; assign A_res := 0; },
			idle -> ex_start{guard A_c == 781; },
			jam -> end_jam{guard A_c == 25000; assign A_Pn := 1,A_start := 0,A_res := 0,A_c := 0; },
			nPf -> check_eof{guard A_Pn == 1; assign A_Pf := 1; },
			nPf -> check_eof{guard A_Pn == 0; assign A_Pf := 0; },
			newPn -> sample{guard A_c == 40,A_err > 0; assign A_Pn := 1; },
			newPn -> sample{guard A_c == 40,A_err == 0; sync A_new_Pn!; },
			other_started -> ex_silence1{guard A_c == 3124,B_start == 0; assign A_c := 0; },
			other_started -> other_started{guard A_c == 3124,B_start == 1; assign A_c := 0; },
			sample -> call_observe{guard A_c == 781; sync one?; assign A_S2 := 1; },
			sample -> call_observe{guard A_c == 781; sync zero?; assign A_S2 := 0; },
			start -> idle{guard A_c == 0; },
			transmit -> check_eof{guard A_c == 781; sync A_frame!; assign A_err := 0,A_diff := 0,A_Pf := 1; },
			until_silence -> hold{guard A_c == 781; sync one?; assign A_c := 0; },
			until_silence -> until_silence{guard A_c == 781; sync zero?; assign A_c := 0; };
}

